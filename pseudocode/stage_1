/* data structures (lookup tables & structs) */
STRUCT Board:
    u64 white,
    u64 black,
    u64 pawns,
    u64 knights,
    u64 bishops,
    u64 rooks,
    u64 queens,
    u64 kings,
ENDSTRUCT

STRUCT Movelist:
    u16 moves[250],
    usize first_empty,
ENDSTRUCT

/* algorithms */
FUNC main():
    uci_main_loop()
ENDFUNC

FUNC uci_main_loop():
    WHILE true:
        input = INPUT_LINE()
        handle_input_line(line)
    ENDWHILE
ENDFUNC

FUNC handle_input_line(line):
    tokens = line.split_on(' ')

    word = line[0]
    SWITCH word:
        case "debug":
            // debug mode
            BREAK
        case "go":
            // start calculating
            BREAK
        // etc.
    ENDSWITCH
ENDFUNC

FUNC pretty_print(bb):
    FOR rank = 7 TO rank = 0:
        FOR file = 0 TO file = 7:
            IF board & (1 << r * 8 + f) != 0:
                OUTPUT("1 ")
            ELSE:
                OUTPUT("0 ")
        NEXT file
        OUTPUT("\n")
    NEXT rank
ENDFUNC

METHOD Board.pretty_print():
    FOR rank = 7 TO rank = 0:
        OUTPUT(rank + " | ")
        FOR file = 0 TO file = 7:
            OUTPUT(char_piece_from_pos(rank, file)
        NEXT file
    NEXT rank
ENDMETHOD

METHOD Board.char_piece_from_pos(rank, file):
    square_bb = bitboard_from_pos(rank, file)
    IF sq_bb & self.white != 0:
        IF sq_bb & self.pawns != 0:
            RETURN 'P'
        ELSE IF sq_bb & self.knights != 0:
            // etc.
        ENDIF
    ELSE IF sq_bb & self.black != 0:
        IF sq_bb & self.pawns != 0:
            RETURN 'p'
        ELSE IF sq_bb & self.knights != 0:
            // etc.
        ENDIF
    ELSE
        RETURN 0
    ENDIF
ENDMETHOD

METHOD Board.make_move(move):
    (start, end, piece, side) = decompose_move(mv)
    self.pieces[piece] ^= 1 << start | 1 << end
    self.sides[side] ^= 1 << start | 1 << end
    self.side_to_move ^= 1
ENDMETHOD

METHOD Board.unmake_move(move):
    (start, end, piece, side) = decompose_move(mv)
    self.pieces[piece] ^= 1 << start | 1 << end
    self.sides[side] ^= 1 << start | 1 << end
    self.side_to_move ^= 1
ENDMETHOD

FUNC perft(depth):
    IF depth == 0:
        RETURN 1
    ENDIF

    generate_moves()

    total = 0
    FOR move IN movelist:
        make_move()
        total += perft(depth - 1)
        unmake_move()
    NEXT move
    RETURN total
ENDFUNC

FUNC find_magics(piece):
    IF piece == BISHOP:
        piece_str = "bishop"
    ELSE
        piece_str = "rook"
    ENDIF

    attacks[4096] = { 0 }
    lookup_table[4096] = { 0 }
    epoch[4096] = { 0 }

    FOR square = 0 TO square = 63:
        IF piece == BISHOP:
            mask = bishop_mask(square, ray_attacks)
        ELSE
            mask = rook_mask(square, ray_attacks)
        ENDIF
        perms = popcnt(mask)
        shift = 64 - perms

        generate_all_ray_attacks(square, piece, ray_attacks, attacks)

        count = 0
        WHILE true:
            sparse_rand = gen_sparse_rand()
            blockers = mask
            found = true

            FOR i = 0 TO i = perms:
                index = blockers * sparse_rand >> shift

                IF epoch[index] < count:
                    epoch[index] = count
                    lookup_table[index] = attacks[i]
                ELSE IF lookup_table[index] != attacks[i]
                    found = false
                    break
                ENDIF
                blockers &= blockers - 1
            NEXT i

            IF found:
                OUTPUT("Found magic for " + piece_str + ": " + sparse_rand)
                break
            ENDIF

            count++
        ENDWHILE
    NEXT square
ENDFUNC

FUNC generate_moves(board, movelist):
    generate_pawn_moves(board, movelist)
    generate_non_sliding_moves(board, movelist)
ENDFUNC

FUNC generate_pawn_moves(board, movelist):
    us = board.side_to_move
    them_bb = board.sides[1 - us]
    empty = ~(board.sides[0] | board.sides[1])
    pawns = board.pieces[0] & board.sides[us]

    WHILE pawns != 0:
        pawn = pop_lsb(&pawns)
        // when we're White, this left-shifts by 8
        // when we're Black, this right-shifts by 8
        single_push = pawn.rotate_left(72 - us * 16) & empty
        captures = pawn_attacks[us][square_of(pawn)] & them_bb
        targets = single_push
        WHILE targets != 0:
            target = pop_next_square(&targets)
            movelist.push_move(to_square(pawn), target)
        ENDWHILE
    ENDWHILE
ENDFUNC

FUNC generate_non_sliding_moves(board, movelist)
    us_bb = board.sides[board.side_to_move]
    knights = board.pieces[1]

    WHILE knights != 0:
        knight = pop_lsb(knights)
        targets = knight_attacks[to_square(knight)] & ~us_bb
        WHILE targets != 0:
            target = pop_next_square(knight)
            movelist.push_move(to_square(pawn), target)
        ENDWHILE
    ENDWHILE

    WHILE king != 0:
        knight = pop_lsb(king)
        targets = knight_attacks[to_square(king)] & ~us_bb
        WHILE targets != 0:
            target = pop_next_square(king)
            movelist.push_move(to_square(pawn), target)
        ENDWHILE
    ENDWHILE
FUNC

FUNC init_pawn_attacks():
    FOR side = 0 TO side = 1:
        FOR square = 0 TO square = 63:
            push = 1 << (square + 8 - side * 16)
            attacks = east(push) | west(push)
            pawn_attacks[side][square] = attacks
        NEXT square
    NEXT side
ENDFUNC

FUNC init_knight_attacks():
    FOR square = 0 TO square = 63
        knight = 1 << square
        e = east(knights)
        w = west(knights)
        attacks = north(north(e | w))
        attacks |= south(south(e | w))
        e = east(e)
        w = west(w)
        attacks = north(north(e | w))
        attacks |= south(south(e | w))
        knight_attacks[square] = attacks
    NEXT square
ENDFUNC

FUNC init_king_attacks():
    FOR square = 0 TO square = 63
        king = 1 << square
        attacks = east(king) | west(king) | king
        attacks |= north(attacks) | south(attacks)
        attacks ^= king
        king_attacks[square] = attacks
    NEXT square
ENDFUNC

FUNC init_ray_attacks(ray_attacks)
    a2_h8 = 0x0101010101010100
    FOR square = 0 TO square = 63:
        ray_attacks[0][square] = a2_h8 << square
    NEXT square

    b2_h8 = 0x8040201008040200
    FOR file = 0 TO file = 6:
        top_rank = file + 56
        FOR square = file TO square = top_rank - 8 STEP 8:
            ray_attacks[1][square] = b2_h8 << square
        NEXT square
        b2_h8 &= ~(0x0101010101010101 << (7 - file))
    NEXT file

    b1_h1 = 0x00000000000000fe
    FOR file = 0 TO file = 6:
        top_rank = file + 56
        FOR square = file TO square = top_rank STEP 8:
            ray_attacks[2][square] = b1_h1 << square
        NEXT square
        b1_h1 &= ~(0x0101010101010101 << (7 - file))
    NEXT file

    b7_h1 = 0x0002040810204080
    square = 56
    WHILE b7_h1 != 0:
        FOR rank = 0 TO rank = 48 STEP 8:
            ray_attacks[3][square] = b7_h1 >> rank
            square -= 8
        NEXT rank

        b7_h1 <<= 1
        b7_h1 &= ~0x0101010101010101
        square += 57
    ENDWHILE

    h7_h1 = 0x0080808080808080
    FOR square = 8 TO square = 56:
        ray_attacks[4][square] = h7_h1 >> (square ^ 63)
    NEXT square

    g7_a1 = 0x0040201008040201
    square = 63
    WHILE g7_a1 != 0:
        FOR file = 0 TO file = 48 STEP 8:
            ray_attacks[5][square] = g7_a1 >> file
            square -= 8
        NEXT file

        g7_a1 >>= 1
        g7_a1 &= ~0x8080808080808080
        square += 55
    ENDWHILE

    square = 7
    g1_a1 = 0x000000000000007f
    WHILE h1_a1 != 0:
        FOR rank = 0 TO rank = 56 STEP 8:
            ray_attacks[6][square] = h1_a1 << rank
            square += 8
        NEXT rank

        h1_a1 >>= 1
        square -= 65
    ENDWHILE

    square = 7
    g2_a8 = 0x0102040810204000
    WHILE g2_a8 != 0:
        FOR rank = 0 TO rank = 48 STEP 8:
            ray_attacks[7][square] = g2_a8 << rank
            square += 8
        NEXT rank

        g2_a8 >>= 1
        g2_a8 &= ~0x8080808080808080
        square -= 57
    ENDWHILE
ENDFUNC


FUNC north(bb)
    bb << 8
ENDFUNC

FUNC south(bb)
    bb >> 8
ENDFUNC

FUNC east(bb)
    FILE_A = 0x0101010101010101
    RETURN bb << 1 & ~FILE_A
ENDFUNC

FUNC west(bb)
    FILE_H = 0x8080808080808080
    RETURN bb >> 1 & ~FILE_H
ENDFUNC

FUNC pop_lsb(&bb):
    ret = *bb & -*bb
    *bb &= *bb - 1
    RETURN ret
ENDFUNC

FUNC pop_next_square(&bb):
    ret = bit_scan_forward(*bb)
    *bb &= *bb - 1
    RETURN ret
ENDFUNC
