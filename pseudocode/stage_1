/* data structures (lookup tables & structs) */
STRUCT Board:
    white:   u64,
    black:   u64,
    pawns:   u64,
    knights: u64,
    bishops: u64,
    rooks:   u64,
    queens:  u64,
    kings:   u64,
ENDSTRUCT

STRUCT Movelist:
    moves: [u16; 250]
    first_empty: usize
ENDSTRUCT

/* algorithms */
FUNC main():
    uci_main_loop()
ENDFUNC

FUNC uci_main_loop():
    WHILE true:
        input = INPUT_LINE()
        handle_input_line(line)
    ENDWHILE
ENDFUNC

FUNC handle_input_line(line):
    tokens = line.split_on(' ')

    word = line[0]
    SWITCH word:
        case "debug":
            // debug mode
            break
        case "go":
            // start calculating
            break
        // etc.
    ENDSWITCH
ENDFUNC

FUNC pretty_print(bb):
    FOR rank = 7 TO rank = 0:
        FOR file = 0 TO file = 7:
            IF board & (1 << r * 8 + f) != 0:
                OUTPUT("1 ")
            ELSE:
                OUTPUT("0 ")
        NEXT file
        OUTPUT("\n")
    NEXT rank
ENDFUNC

METHOD Board.pretty_print():
    FOR rank = 7 TO rank = 0:
        OUTPUT(rank + " | ")
        FOR file = 0 TO file = 7:
            OUTPUT(char_piece_from_pos(rank, file)
        NEXT file
    NEXT rank
ENDMETHOD

METHOD Board.char_piece_from_pos(rank, file):
    square_bb = bitboard_from_pos(rank, file)
    IF sq_bb & self.white != 0:
        IF sq_bb & self.pawns != 0:
            RETURN 'P'
        ELSE IF sq_bb & self.knights != 0:
            // etc.
        ENDIF
    ELSE IF sq_bb & self.black != 0:
        IF sq_bb & self.pawns != 0:
            RETURN 'p'
        ELSE IF sq_bb & self.knights != 0:
            // etc.
        ENDIF
    ELSE
        RETURN 0
    ENDIF
ENDMETHOD

METHOD Board.make_move(move):
    (start, end, piece, side) = decompose_move(mv)
    self.pieces[piece] ^= 1 << start | 1 << end
    self.sides[side] ^= 1 << start | 1 << end
    self.side_to_move ^= 1
ENDMETHOD

METHOD Board.unmake_move(move):
    (start, end, piece, side) = decompose_move(mv)
    self.pieces[piece] ^= 1 << start | 1 << end
    self.sides[side] ^= 1 << start | 1 << end
    self.side_to_move ^= 1
ENDMETHOD

FUNC perft(depth):
    IF depth == 0:
        RETURN 1
    ENDIF

    generate_moves()

    total = 0
    FOR move IN movelist:
        make_move()
        total += perft(depth - 1)
        unmake_move()
    NEXT move
    RETURN total
ENDFUNC

FUNC generate_moves(board, movelist):
    generate_pawn_moves(board, movelist)
ENDFUNC

FUNC generate_pawn_moves(board, movelist):
    us = board.side_to_move
    them_bb = board.sides[1 - us]
    empty = ~(board.sides[0] | board.sides[1])
    pawns = board.pieces[0] & board.sides[us]

    WHILE board.pawns != 0:
        pawn = pop_lsb(&board.pawns)
        // when we're White, this left-shifts by 8
        // when we're Black, this right-shifts by 8
        single_push = pawn.rotate_left(72 - us * 16) & empty
        captures = pawn_attacks[us][square_of(pawn)] & them_bb
        targets = single_push
        WHILE targets != 0:
            target = pop_next_square(&targets)
            movelist.push_move(to_square(pawn), target)
        ENDWHILE
    ENDWHILE
ENDFUNC

FUNC init_pawn_attacks():
    FOR side = 0 TO side = 1:
        FOR square = 0 TO square = 63:
            push = 1 << (square + 8 - side * 16)
            attacks = east(push) | west(push)
            pawn_attacks[side][square] = attacks
        NEXT square
    NEXT side
ENDFUNC

FUNC init_knight_attacks():
    FOR square = 0 TO square = 63
        knight = 1 << square
        e = east(knights)
        w = west(knights)
        attacks = north(north(e | w))
        attacks |= south(south(e | w))
        e = east(e)
        w = west(w)
        attacks = north(north(e | w))
        attacks |= south(south(e | w))
    NEXT square
ENDFUNC

FUNC north(bb)
    bb << 8
ENDFUNC

FUNC south(bb)
    bb >> 8
ENDFUNC

FUNC east(bb)
    FILE_A = 0x0101010101010101
    RETURN bb << 1 & ~FILE_A
ENDFUNC

FUNC west(bb)
    FILE_H = 0x8080808080808080
    RETURN bb >> 1 & ~FILE_H
ENDFUNC

FUNC pop_lsb(&bb):
    ret = *bb & -*bb
    *bb &= *bb - 1
    RETURN ret
ENDFUNC

FUNC pop_next_square(&bb):
    ret = bit_scan_forward(*bb)
    *bb &= *bb - 1
    RETURN ret
ENDFUNC

FUNC pop_next_square(&bb):
    shift = *bb.trailing_zeros()
    *bb ^= 1 << shift
    return shift
ENDFUNC
