/* data structures (lookup tables) */


/* constants - not technically important but needed to understand the
   algorithms */
FILE1 = 0
FILE8 = 7
RANK1 = 0
RANK8 = 7
SQ_A1 = 0
SQ_A2 = 1
// ...
SQ_A8 = 7
// ...
SQ_B8 = 15
// ..
SQ_H8 = 63
/* 1 0 0 0 0 0 0 0
 * 1 0 0 0 0 0 0 0
 * ...
 * 1 0 0 0 0 0 0 0
 */
FILE1_BB = 0x0101010101010101
/* 0 0 0 0 0 0 0 1
 * 0 0 0 0 0 0 0 1
 * ...
 * 0 0 0 0 0 0 0 1
 */
FILE8_BB = 0x8080808080808080
/* 0 0 0 0 0 0 0 0
 * 0 0 0 0 0 0 0 0
 * ...
 * 1 1 1 1 1 1 1 1
 */
RANK1_BB = 0x00000000000000ff
RANK4_BB = 0x00000000ff000000
/* 1 1 1 1 1 1 1 1
 * 0 0 0 0 0 0 0 0
 * ...
 * 0 0 0 0 0 0 0 0
 */
RANK8_BB = 0xff00000000000000


/* algorithms */
FUNC perft(depth):
    IF depth == 0:
        RETURN 1
    ENDIF
    generate_moves()
    total = 0
    FOR move IN movelist:
        total += perft(depth - 1)
    NEXT move
    RETURN total
ENDFUNC

FUNC generate_moves(board, movelist):
    generate_pawn_moves(board, movelist)
    generate_non_sliding_moves<KNIGHT>(board, movelist)
    generate_non_sliding_moves<KING>(board, movelist)
    generate_sliding_moves<BISHOP>(board, movelist)
    generate_sliding_moves<ROOK>(board, movelist)
    generate_sliding_moves<QUEEN>(board, movelist)
ENDFUNC

FUNC generate_pawn_moves(board, movelist):
    WHILE board.pawns != 0:
        src = pop_next_square(&board.pawns)
        // random number from 0 to 63
        dest = random(0, 63)
        movelist.push_move<PAWN>(lsb, dest)
    ENDWHILE
ENDFUNC

// NON_SLIDING_PIECE == {KNIGHT,KING} - not pawn
FUNC generate_non_sliding_moves<NON_SLIDING_PIECE>(board, movelist):
    IF PIECE == KNIGHT:
        src = pop_next_square(&board.knights)
        // random number from 0 to 63
        dest = random(0, 63)
        movelist.push_move<PAWN>(lsb, dest)
    ELSE
        src = pop_next_square(&board.kings)
        // random number from 0 to 63
        dest = random(0, 63)
        movelist.push_move<PAWN>(lsb, dest)
    ENDIF
ENDFUNC

// SLIDING_PIECE == {BISHOP,ROOK,QUEEN}
FUNC generate_sliding_moves<SLIDING_PIECE>(board, movelist):
    // this is more Rust than pseudocode, but the distiction
    // between a switch and match statement is important
    MATCH SLIDING_PIECE:
        BISHOP:
            src = pop_next_square(&board.bishops)
            // random number from 0 to 63
            dest = random(0, 63)
            movelist.push_move<PAWN>(lsb, dest)
        ROOK:
            src = pop_next_square(&board.rooks)
            // random number from 0 to 63
            dest = random(0, 63)
            movelist.push_move<PAWN>(lsb, dest)
        QUEEN:
            src = pop_next_square(&board.queens)
            // random number from 0 to 63
            dest = random(0, 63)
            movelist.push_move<PAWN>(lsb, dest)
    ENDMATCH
ENDFUNC

FUNC pop_next_square(&bb):
    shift = *bb.trailing_zeros
    *bb ^= 1 << shift
    return shift
ENDFUNC
