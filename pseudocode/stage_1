/* data structures (lookup tables & structs) */
STRUCT Board:
    Movelist played_moves,
    u64 pieces[6],
    u64 sides[2],
    usize piece_array[64],
    usize ep_square,
    bool side_to_move,
ENDSTRUCT

STRUCT ChessMove:
    Move move,
    usize captured,
    usize piece,
    usize ep_square,
ENDSTRUCT

STRUCT Magic:
    u64 magic,
    u64 mask,
    u32 shift,
    u32 offset,
ENDSTRUCT

STRUCT Move:
    u16 move,
ENDSTRUCT

STRUCT Movelist:
    ChessMove moves[250],
    usize first_empty,
ENDSTRUCT

u64 pawn_attacks[2][64]
u64 knight_attacks[64]
u64 king_attacks[64]
Magic bishop_magics[64]
Magic rook_magics[64]
// C++-style number deliminators
u64 bishop_magic_lookup[5'248]
u64 rook_magic_lookup[102'400]

/* algorithms */
FUNC main():
    uci_main_loop()
ENDFUNC

FUNC uci_main_loop():
    WHILE true:
        input = INPUT_LINE()
        handle_input_line(line)
    ENDWHILE
ENDFUNC

FUNC handle_input_line(line):
    tokens = line.split_on(' ')

    word = line[0]
    SWITCH word:
        case "debug":
            // debug mode
            BREAK
        case "go":
            // start calculating
            BREAK
        // etc.
    ENDSWITCH
ENDFUNC

FUNC pretty_print(bb):
    FOR rank = 7 TO rank = 0:
        FOR file = 0 TO file = 7:
            IF board & (1 << r * 8 + f) != 0:
                OUTPUT("1 ")
            ELSE:
                OUTPUT("0 ")
        NEXT file
        OUTPUT("\n")
    NEXT rank
ENDFUNC

FUNC Board.new():
    piece_board:
    {
        3, 1, 2, 4, 5, 2, 1, 3,
        0, 0, 0, 0, 0, 0, 0, 0,
        6, 6, 6, 6, 6, 6, 6, 6,
        6, 6, 6, 6, 6, 6, 6, 6,
        6, 6, 6, 6, 6, 6, 6, 6,
        6, 6, 6, 6, 6, 6, 6, 6,
        0, 0, 0, 0, 0, 0, 0, 0,
        3, 1, 2, 4, 5, 2, 1, 3,
    },
    pieces:
    {
        0x00ff00000000ff00,
        0x4200000000000042,
        0x2400000000000024,
        0x8100000000000081,
        0x0800000000000080,
        0x1000000000000010,
    },
    sides:
    {
        0xffff000000000000,
        0x000000000000ffff,
    },
    ep_square: 64,
    side_to_move: 1,
ENDFUNC

METHOD Board.pretty_print():
    FOR rank = 7 TO rank = 0:
        OUTPUT(rank + " | ")
        FOR file = 0 TO file = 7:
            OUTPUT(char_piece_from_pos(rank, file)
        NEXT file
    NEXT rank
ENDMETHOD

METHOD Board.char_piece_from_pos(rank, file):
    square_bb = bitboard_from_pos(rank, file)
    IF sq_bb & self.white != 0:
        IF sq_bb & self.pawns != 0:
            RETURN 'P'
        ELSE IF sq_bb & self.knights != 0:
            // etc.
        ENDIF
    ELSE IF sq_bb & self.black != 0:
        IF sq_bb & self.pawns != 0:
            RETURN 'p'
        ELSE IF sq_bb & self.knights != 0:
            // etc.
        ENDIF
    ELSE
        RETURN 0
    ENDIF
ENDMETHOD

METHOD Board.make_move(move):
    (start, end, _is_castling, is_en_passant, is_promotion, promotion_piece) =
        decompose_move(move)
    piece = self.piece_on(start)
    captured = self.piece_on(end)
    us = self.side_to_move
    them = us ^ 1

    start_bb = as_bitboard(start)
    end_bb = as_bitboard(end)

    self.played_moves.push_move(move, piece, captured)

    self.pieces[piece] ^= start_bb | end_bb
    self.sides[us] ^= start_bb | end_bb
    NO_SQUARE = 64
    self.piece_board[start] = NO_SQUARE
    self.ep_square = NO_SQUARE

    NO_PIECE = 6
    IF captured != NO_PIECE:
        self.pieces[captured] ^= end_bb
        self.sides[them] ^= end_bb
    ELSE IF is_double_pawn_push(start, end, piece):
        self.ep_square = (start + end) >> 1
    ELSE IF is_en_passant:
        WHITE = 1
        IF self.side_to_move == WHITE:
            dest = end - 8
        ELSE
            dest = end + 8
        ENDIF
        self.piece_board[dest] = NO_PIECE
        self.pieces[0] ^= 1 << dest
    ENDIF

    IF is_promotion:
        self.piece_board[end] = promotion_piece
        self.pieces[0] ^= end_bb
        self.pieces[promotion_piece] ^= end_bb
    ELSE
        self.piece_board[end] = piece
    ENDIF

    self.side_to_move ^= 1
ENDMETHOD

METHOD Board.unmake_move():
    (
        start,
        end,
        _is_castling,
        is_en_passant,
        is_promotion,
        promotion_piece,
        piece,
        captured,
        ep_square,
    ) = self.played_moves.pop_move().decompose()
    self.side_to_move ^= 1
    us = self.side_to_move
    them = us ^ 1

    start_bb = as_bitboard(start)
    end_bb = as_bitboard(end)

    self.pieces[piece] ^= start_bb | end_bb;
    self.sides[us] ^= start_bb | end_bb;
    self.piece_board[end] = captured
    self.piece_board[start] = piece
    NO_PIECE = 6
    self.ep_square = NO_PIECE

    IF captured != NO_PIECE:
        self.pieces[captured] ^= end_bb
        self.sides[them] ^= end_bb
    ELSE IF is_en_passant:
        WHITE = 1
        IF self.side_to_move = WHITE:
            dest = end - 8
        ELSE
            dest = end + 8
        ENDIF
        PAWN = 0
        self.piece_board[dest] = PAWN
        self.pieces[PAWN] = 1 << dest
        self.ep_square = ep_square
    ENDIF

    IF is_promotion:
        self.pieces[0] ^= end_bb
        self.pieces[promotion_piece] ^= end_bb
    ENDIF
ENDMETHOD

METHOD ChessMove.decompose():
    (start, end, is_castling, is_en_passant, is_promotion, promotion_piece)
        = self.move.decompose()
    (
        start,
        end,
        is_castling,
        is_en_passant,
        is_promotion,
        promotion_piece,
        self.piece,
        self.captured,
        self.ep_square,
    )
ENDMETHOD

FUNC ChessMove.new(move, piece, captured, ep_square):
    RETURN Self:
        move,
        captured,
        piece,
        ep_square,
ENDFUNC

FUNC Move.new(flag, start, end):
    RETURN Self:
        mv: start | (end << 6) | flag
ENDFUNC

FUNC Move.new_promo(start, end, promotion_piece):
    EP_FLAG = 0b0010_0000_0000_0000
    RETURN Self:
        start | (end << 6) | EP_FLAG | (promotion_piece - 1) << 14
ENDFUNC

METHOD Move.decompose():
    start = self.move & 0x3f
    end = (self.move & 0xfc0) >> 6
    is_promotion = self.is_promotion()
    is_castling = self.is_castling()
    is_en_passant = self.is_en_passant()
    piece = (self.move >> 14) + 1
    (
        start,
        end,
        is_castling,
        is_en_passant,
        is_promotion,
        piece,
    )
ENDMETHOD

METHOD Move.is_promotion():
    self.move & 0x3000 == 0x3000
ENDMETHOD

METHOD Move.is_en_passant():
    self.move & 0x2000 != 0 && !self.is_promotion()
ENDMETHOD

METHOD Move.is_castling():
    self.move & 0x1000 != 0 && !self.is_promotion()
ENDMETHOD

METHOD Movelist.push_move(move, piece, captures, ep_square):
    self.moves[self.first_empty] = ChessMove::new(move, piece, captures, ep_square)
    first_empty += 1
ENDMETHOD

METHOD Movelist.pop_move():
    self.first_empty -= 1
    RETURN self.moves[self.first_empty]
ENDMETHOD

FUNC perft(depth):
    IF depth == 0:
        RETURN 1
    ENDIF

    generate_moves()

    total = 0
    FOR move IN movelist:
        make_move()
        total += perft(depth - 1)
        unmake_move()
    NEXT move
    RETURN total
ENDFUNC

FUNC init_magics():
    b_offset = 0
    r_offset = 0

    FOR square = 0 TO square = 63:
        attacks[4096] = { 0 }
        edges = 0x8181818181818181 & !(0x0101010101010101 << file_of(square))
            | 0xff000000000000ff & !(0x00000000000000ff << rank_of(square))
        b_mask = sliding_attacks(square, 2, 0) & !edges
        r_mask = sliding_attacks(square, 3, 0) & !edges
        b_mask_bits = popcnt(b_mask)
        r_mask_bits = popcnt(r_mask)
        b_perms = pow(2, b_mask_bits)
        r_perms = pow(2, r_mask_bits)
        b_magic = Magic:
            magic = BISHOP_MAGICS[square],
            mask = b_mask,
            offset = b_offset,
            shift = 64 - b_mask_bits
        r_magic = Magic:
            magic = ROOK_MAGICS[square],
            mask = r_mask,
            offset = r_offset,
            shift = 64 - r_mask_bits

        generate_all_ray_attacks(square, piece, ray_attacks, attacks)
        blockers = b_mask
        FOR attack = 0 TO attack = b_perms:
            index = get_table_index(b_magic, blockers)
            bishop_magic_lookup[index] = attacks[attack]
            blockers = blockers - 1 & b_mask
        NEXT attack
        bishop_magics[square] = b_magic
        b_offset += b_perms

        generate_all_ray_attacks(square, piece, ray_attacks, attacks)
        blockers = r_mask
        FOR attack = 0 TO attack = r_perms:
            index = get_table_index(r_magic, blockers)
            rook_magic_lookup[index] = attacks[attack]
            blockers = blockers - 1 & r_mask
        NEXT attack
        rook_magics[square] = r_magic
        r_offset += r_perms
    NEXT square
ENDFUNC

FUNC find_magics(piece):
    IF piece == BISHOP:
        piece_str = "bishop"
    ELSE
        piece_str = "rook"
    ENDIF

    ray_attacks[8][64]
    attacks[4096] = { 0 }
    lookup_table[4096] = { 0 }
    epoch[4096] = { 0 }
    init_ray_attacks(ray_attacks)

    FOR square = 0 TO square = 63:
        IF piece == BISHOP:
            mask = bishop_mask(square, ray_attacks)
        ELSE
            mask = rook_mask(square, ray_attacks)
        ENDIF
        perms = popcnt(mask)
        shift = 64 - perms

        generate_all_ray_attacks(square, piece, ray_attacks, attacks)

        count = 0
        WHILE true:
            sparse_rand = gen_sparse_rand()
            blockers = mask
            found = true

            FOR i = 0 TO i = perms:
                index = blockers * sparse_rand >> shift

                IF epoch[index] < count:
                    epoch[index] = count
                    lookup_table[index] = attacks[i]
                ELSE IF lookup_table[index] != attacks[i]
                    found = false
                    break
                ENDIF
                blockers &= blockers - 1
            NEXT i

            IF found:
                OUTPUT("Found magic for " + piece_str + ": " + sparse_rand)
                break
            ENDIF

            count++
        ENDWHILE
    NEXT square
ENDFUNC

FUNC generate_moves(board, movelist):
    generate_pawn_moves(board, movelist)
    generate_non_sliding_moves(board, movelist)
    generate_sliding_moves(board, movelist)
ENDFUNC

FUNC generate_pawn_moves(board, movelist):
    us_bb = board.sides::<IS_WHITE>
    occupancies = board.occupancies()
    them_bb = occupancies ^ us_bb
    NO_SQUARE = 64
    IF self.ep_square == NO_SQUARE:
        ep_square_bb = 0
    ELSE
        ep_square_bb = 1 << self.ep_square
    ENDIF
    empty = !occupancies

    pawns = board.pieces::<0> & us_bb
    WHILE pawns != 0:
        pawn = pop_lsb(&pawns)
        pawn_sq = to_square(pawn)

        single_push = pawn_push::<IS_WHITE>(pawn)
        IF IS_WHITE:
            double_push_rank = 0x00000000ff000000
        ELSE:
            double_push_rank = 0x000000ff00000000
        ENDIF
        double_push = pawn_push::<IS_WHITE>(single_push)
            & empty
            // 4 if we're White, 5 if we're Black
            & double_push_rank

        all_captures = pawn_attacks::<IS_WHITE>(pawn_sq)
        normal_captures = all_captures & them_bb
        ep_captures = all_captures & ep_square_bb

        targets = single_push | double_push | all_captures
        promotion_targets = targets & 0xff0000000000ff
        targets ^= promotion_targets

        WHILE targets != 0:
            target = pop_next_square(&targets)
            movelist.push_move(Move::new<NO_FLAG>(pawn_sq, target))
        ENDWHILE
        WHILE promotion_targets != 0:
            target = pop_next_square(&promotion_targets)
            movelist.push_move(Move::new<KNIGHT>(pawn_sq, target))
            movelist.push_move(Move::new<BISHOP>(pawn_sq, target))
            movelist.push_move(Move::new<ROOK>(pawn_sq, target))
            movelist.push_move(Move::new<QUEEN>(pawn_sq, target))
        ENDWHILE
        WHILE ep_captures != 0:
            target = pop_next_square(&ep_captures)
            movelist.push_move(create_move::<IS_WHITE, 4>(pawn_sq, target))
    ENDWHILE
ENDFUNC

FUNC generate_non_sliding_moves(board, movelist):
    us_bb = board.sides[board.side_to_move]
    knights = board.pieces[1]

    WHILE knights != 0:
        knight = pop_next_square(&knights)
        targets = knight_attacks[knight] & ~us_bb
        WHILE targets != 0:
            target = pop_next_square(&targets)
            movelist.push_move(Move::new<NO_FLAG>(knight, target)
        ENDWHILE
    ENDWHILE

    WHILE kings != 0:
        king = pop_lsb(&kings)
        targets = king_attacks[king] & ~us_bb
        WHILE targets != 0:
            target = pop_next_square(&targets)
            movelist.push_move(Move::new<NO_FLAG>(king, target)
        ENDWHILE
    ENDWHILE
FUNC

FUNC generate_sliding_moves(board, movelist):
    us = board.side_to_move
    us_bb = board.sides[us]
    them_bb = board.sides[1 - us]
    occupancies = us_bb | them_bb

    bishops = board.pieces[2] & us_bb
    WHILE bishops != 0:
        bishop = pop_next_square(&bishops)
        targets = bishop_magic_lookup[
            get_table_index(bishop_magics[bishop], occupancies)
        ] & !us_bb
        WHILE targets != 0:
            target = pop_next_square(&targets)
            movelist.push_move(Move::new<NO_FLAG>(bishop, target))
        ENDWHILE
    ENDWHILE

    rooks = board.pieces[3] & us_bb
    WHILE rooks != 0:
        rook = pop_next_square(&rooks)
        targets = rook_magic_lookup[
            get_table_index(rook_magics[rook], occupancies)
        ] & !us_bb
        WHILE targets != 0:
            target = pop_next_square(&targets)
            movelist.push_move(Move::new<NO_FLAG>(rook, target))
        ENDWHILE
    ENDWHILE

    queens = board.pieces[4] & us_bb
    WHILE queens != 0:
        queen = pop_next_square(&queens)
        targets = rook_magic_lookup[
            get_table_index(rook_magics[queen], occupancies)
        ] | bishop_magic_lookup[
            get_table_index(bishop_magics[queen], occupancies)
        ] & !us_bb
        WHILE targets != 0:
            target = pop_next_square(&targets)
            movelist.push_move(Move::new<NO_FLAG>(queen, target))
        ENDWHILE
    ENDWHILE
ENDFUNC

FUNC init_pawn_attacks():
    FOR side = 0 TO side = 1:
        FOR square = 0 TO square = 63:
            push = 1 << (square + 8 - side * 16)
            attacks = east(push) | west(push)
            pawn_attacks[side][square] = attacks
        NEXT square
    NEXT side
ENDFUNC

FUNC init_knight_attacks():
    FOR square = 0 TO square = 63
        knight = 1 << square
        e = east(knights)
        w = west(knights)
        attacks = north(north(e | w))
        attacks |= south(south(e | w))
        e = east(e)
        w = west(w)
        attacks = north(north(e | w))
        attacks |= south(south(e | w))
        knight_attacks[square] = attacks
    NEXT square
ENDFUNC

FUNC init_king_attacks():
    FOR square = 0 TO square = 63
        king = 1 << square
        attacks = east(king) | west(king) | king
        attacks |= north(attacks) | south(attacks)
        attacks ^= king
        king_attacks[square] = attacks
    NEXT square
ENDFUNC

FUNC init_ray_attacks(ray_attacks):
    a2_h8 = 0x0101010101010100
    FOR square = 0 TO square = 63:
        ray_attacks[0][square] = a2_h8 << square
    NEXT square

    b2_h8 = 0x8040201008040200
    FOR file = 0 TO file = 6:
        top_rank = file + 56
        FOR square = file TO square = top_rank - 8 STEP 8:
            ray_attacks[1][square] = b2_h8 << square
        NEXT square
        b2_h8 &= ~(0x0101010101010101 << (7 - file))
    NEXT file

    b1_h1 = 0x00000000000000fe
    FOR file = 0 TO file = 6:
        top_rank = file + 56
        FOR square = file TO square = top_rank STEP 8:
            ray_attacks[2][square] = b1_h1 << square
        NEXT square
        b1_h1 &= ~(0x0101010101010101 << (7 - file))
    NEXT file

    b7_h1 = 0x0002040810204080
    square = 56
    WHILE b7_h1 != 0:
        FOR rank = 0 TO rank = 48 STEP 8:
            ray_attacks[3][square] = b7_h1 >> rank
            square -= 8
        NEXT rank

        b7_h1 <<= 1
        b7_h1 &= ~0x0101010101010101
        square += 57
    ENDWHILE

    h7_h1 = 0x0080808080808080
    FOR square = 8 TO square = 56:
        ray_attacks[4][square] = h7_h1 >> (square ^ 63)
    NEXT square

    g7_a1 = 0x0040201008040201
    square = 63
    WHILE g7_a1 != 0:
        FOR file = 0 TO file = 48 STEP 8:
            ray_attacks[5][square] = g7_a1 >> file
            square -= 8
        NEXT file

        g7_a1 >>= 1
        g7_a1 &= ~0x8080808080808080
        square += 55
    ENDWHILE

    square = 7
    g1_a1 = 0x000000000000007f
    WHILE h1_a1 != 0:
        FOR rank = 0 TO rank = 56 STEP 8:
            ray_attacks[6][square] = h1_a1 << rank
            square += 8
        NEXT rank

        h1_a1 >>= 1
        square -= 65
    ENDWHILE

    square = 7
    g2_a8 = 0x0102040810204000
    WHILE g2_a8 != 0:
        FOR rank = 0 TO rank = 48 STEP 8:
            ray_attacks[7][square] = g2_a8 << rank
            square += 8
        NEXT rank

        g2_a8 >>= 1
        g2_a8 &= ~0x8080808080808080
        square -= 57
    ENDWHILE
ENDFUNC

FUNC is_double_pawn_push(start, end, piece):
    IF piece != 0:
        RETURN false
    ENDIF
    start_bb = 1 << start
    end_bb = 1 << end
    IF start_bb & 0x00ff00000000ff00 != 0:
        RETURN false
    ENDIF
    IF end_bb & 0x000000ffff000000 != 0:
        RETURN false
    ENDIF
    RETURN true
ENDFUNC

FUNC north(bb):
    bb << 8
ENDFUNC

FUNC south(bb):
    bb >> 8
ENDFUNC

FUNC east(bb):
    FILE_A = 0x0101010101010101
    RETURN bb << 1 & ~FILE_A
ENDFUNC

FUNC west(bb):
    FILE_H = 0x8080808080808080
    RETURN bb >> 1 & ~FILE_H
ENDFUNC

FUNC pop_lsb(&bb):
    ret = *bb & -*bb
    *bb &= *bb - 1
    RETURN ret
ENDFUNC

FUNC pop_next_square(&bb):
    ret = bit_scan_forward(*bb)
    *bb &= *bb - 1
    RETURN ret
ENDFUNC
