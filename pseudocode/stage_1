/* data structures (lookup tables & structs) */
STRUCT Board:
    white:   u64,
    black:   u64,
    pawns:   u64,
    knights: u64,
    bishops: u64,
    rooks:   u64,
    queens:  u64,
    kings:   u64,
ENDSTRUCT

STRUCT Movelist:
    moves: [u16; 250]
    first_empty: usize
ENDSTRUCT

/* algorithms */
FUNC main():
    uci_main_loop()
ENDFUNC

FUNC uci_main_loop():
    WHILE true:
        input = INPUT_LINE()
        handle_input_line(line)
    ENDWHILE
ENDFUNC

FUNC handle_input_line(line):
    tokens = line.split_on(' ')

    word = line[0]
    SWITCH word:
        case "debug":
            // debug mode
            BREAK
        case "go":
            // start calculating
            BREAK
        // etc.
    ENDSWITCH
ENDFUNC

FUNC pretty_print(bb):
    FOR rank = 7 TO rank = 0:
        FOR file = 0 TO file = 7:
            IF board & (1 << r * 8 + f) != 0:
                OUTPUT("1 ")
            ELSE:
                OUTPUT("0 ")
        NEXT file
        OUTPUT("\n")
    NEXT rank
ENDFUNC

METHOD Board.pretty_print():
    FOR rank = 7 TO rank = 0:
        OUTPUT(rank + " | ")
        FOR file = 0 TO file = 7:
            OUTPUT(char_piece_from_pos(rank, file)
        NEXT file
    NEXT rank
ENDMETHOD

METHOD Board.char_piece_from_pos(rank, file):
    square_bb = bitboard_from_pos(rank, file)
    IF sq_bb & self.white != 0:
        IF sq_bb & self.pawns != 0:
            RETURN 'P'
        ELSE IF sq_bb & self.knights != 0:
            // etc.
        ENDIF
    ELSE IF sq_bb & self.black != 0:
        IF sq_bb & self.pawns != 0:
            RETURN 'p'
        ELSE IF sq_bb & self.knights != 0:
            // etc.
        ENDIF
    ELSE
        RETURN 0
    ENDIF
ENDMETHOD

METHOD Board.make_move(move):
    (start, end, piece, side) = decompose_move(mv)
    self.pieces[piece] ^= 1 << start | 1 << end
    self.sides[side] ^= 1 << start | 1 << end
    self.side_to_move ^= 1
ENDMETHOD

METHOD Board.unmake_move(move):
    (start, end, piece, side) = decompose_move(mv)
    self.pieces[piece] ^= 1 << start | 1 << end
    self.sides[side] ^= 1 << start | 1 << end
    self.side_to_move ^= 1
ENDMETHOD

FUNC perft(depth):
    IF depth == 0:
        RETURN 1
    ENDIF

    generate_moves()

    total = 0
    FOR move IN movelist:
        make_move()
        total += perft(depth - 1)
        unmake_move()
    NEXT move
    RETURN total
ENDFUNC

FUNC generate_moves(board, movelist):
    generate_pawn_moves(board, movelist)
    generate_non_sliding_moves(board, movelist)
ENDFUNC

FUNC generate_pawn_moves(board, movelist):
    us = board.side_to_move
    them_bb = board.sides[1 - us]
    empty = ~(board.sides[0] | board.sides[1])
    pawns = board.pieces[0] & board.sides[us]

    WHILE pawns != 0:
        pawn = pop_lsb(&pawns)
        // when we're White, this left-shifts by 8
        // when we're Black, this right-shifts by 8
        single_push = pawn.rotate_left(72 - us * 16) & empty
        captures = pawn_attacks[us][square_of(pawn)] & them_bb
        targets = single_push
        WHILE targets != 0:
            target = pop_next_square(&targets)
            movelist.push_move(to_square(pawn), target)
        ENDWHILE
    ENDWHILE
ENDFUNC

FUNC generate_non_sliding_moves(board, movelist)
    us_bb = board.sides[board.side_to_move]
    knights = board.pieces[1]

    WHILE knights != 0:
        knight = pop_lsb(knights)
        targets = knight_attacks[to_square(knight)] & ~us_bb
        WHILE targets != 0:
            target = pop_next_square(knight)
            movelist.push_move(to_square(pawn), target)
        ENDWHILE
    ENDWHILE

    WHILE king != 0:
        knight = pop_lsb(king)
        targets = knight_attacks[to_square(king)] & ~us_bb
        WHILE targets != 0:
            target = pop_next_square(king)
            movelist.push_move(to_square(pawn), target)
        ENDWHILE
    ENDWHILE
FUNC

FUNC init_pawn_attacks():
    FOR side = 0 TO side = 1:
        FOR square = 0 TO square = 63:
            push = 1 << (square + 8 - side * 16)
            attacks = east(push) | west(push)
            pawn_attacks[side][square] = attacks
        NEXT square
    NEXT side
ENDFUNC

FUNC init_knight_attacks():
    FOR square = 0 TO square = 63
        knight = 1 << square
        e = east(knights)
        w = west(knights)
        attacks = north(north(e | w))
        attacks |= south(south(e | w))
        e = east(e)
        w = west(w)
        attacks = north(north(e | w))
        attacks |= south(south(e | w))
        knight_attacks[square] = attacks
    NEXT square
ENDFUNC

FUNC init_king_attacks():
    FOR square = 0 TO square = 63
        king = 1 << square
        attacks = east(king) | west(king) | king
        attacks |= north(attacks) | south(attacks)
        attacks ^= king
        king_attacks[square] = attacks
    NEXT square
ENDFUNC

FUNC ray(direction, square):
    SWITCH direction:
        CASE N:
            RETURN 0x0101010101010100 << square
        CASE NE:
            file = file_of(square)
            left_files = (1 << file) - 1
            left_files |= left_files << 8
            left_files |= left_files << 16
            left_files |= left_files << 32
            b2_h8_diag = 0x8040201008040200
            RETURN (b2_h8_diag << square) & ~left_files
        CASE E:
            square_bb = 1 << square
            highest_bit_of_rank = 1 << (square | 7)
            RETURN (highest_bit_of_rank - square_bb) << 1
        CASE SE:
            lower_ranks = (1 << square) - 1
            file = file_of(square)
            left_files = (1 << file) - 1
            left_files |= left_files << 8
            left_files |= left_files << 16
            left_files |= left_files << 32
            b7_h1_diag = 0x0002040810204080
            RETURN rotate_left(b7_h1_diag, 64 + square - 56) & ~left_files & lower_ranks
        CASE S:
            RETURN (0x0080808080808080) >> (square ^ 63)
        CASE SW:
            lower_ranks = (1 << square) - 1
            file = file_of(square)
            left_files = (1 << file) - 1
            left_files |= left_files << 8
            left_files |= left_files << 16
            left_files |= left_files << 32
            a1_g7_diag = 0x0040201008040201
            RETURN rotate_left(a1_g7_diag, 64 + square - 63) & left_files & lower_ranks
        CASE W:
            square_bb = 1 << square
            lowest_bit = 1 << (square & 56)
            RETURN square_bb - lowest_bit
        CASE NW:
            upper_ranks = Bitboards::FULL << square
            file = file_of(square)
            left_files = (1 << file) - 1
            left_files |= left_files << 8
            left_files |= left_files << 16
            left_files |= left_files << 32
            a8_g2_diag = 0x0102040810204000
            RETURN rotate_left(a8_g2_diag, 64 + square - 7) & left_files & upper_ranks
        // no default case needed because there cannot be any more variants in Rust.
    ENDSWITCH
ENDFUNC


FUNC north(bb)
    bb << 8
ENDFUNC

FUNC south(bb)
    bb >> 8
ENDFUNC

FUNC east(bb)
    FILE_A = 0x0101010101010101
    RETURN bb << 1 & ~FILE_A
ENDFUNC

FUNC west(bb)
    FILE_H = 0x8080808080808080
    RETURN bb >> 1 & ~FILE_H
ENDFUNC

FUNC pop_lsb(&bb):
    ret = *bb & -*bb
    *bb &= *bb - 1
    RETURN ret
ENDFUNC

FUNC pop_next_square(&bb):
    ret = bit_scan_forward(*bb)
    *bb &= *bb - 1
    RETURN ret
ENDFUNC
