/* data structures (lookup tables & structs) */
STRUCT Board:
    Movelist played_moves,
    u64 pieces[6],
    u64 sides[2],
    usize piece_array[64],
    bool side_to_move,
ENDSTRUCT

STRUCT GameMove:
    usize captured,
    Move move,
    usize piece,
ENDSTRUCt

STRUCT Magic:
    u64 magic,
    u64 mask,
    u32 shift,
    u32 offset,
ENDSTRUCT

STRUCT Move:
    u16 move,
ENDSTRUCT

STRUCT Movelist:
    GameMove moves[250],
    usize first_empty,
ENDSTRUCT

u64 pawn_attacks[2][64]
u64 knight_attacks[64]
u64 king_attacks[64]
Magic bishop_magics[64]
Magic rook_magics[64]
// C++-style number deliminators
u64 bishop_magic_lookup[5'248]
u64 rook_magic_lookup[102'400]

/* algorithms */
FUNC main():
    uci_main_loop()
ENDFUNC

FUNC uci_main_loop():
    WHILE true:
        input = INPUT_LINE()
        handle_input_line(line)
    ENDWHILE
ENDFUNC

FUNC handle_input_line(line):
    tokens = line.split_on(' ')

    word = line[0]
    SWITCH word:
        case "debug":
            // debug mode
            BREAK
        case "go":
            // start calculating
            BREAK
        // etc.
    ENDSWITCH
ENDFUNC

FUNC pretty_print(bb):
    FOR rank = 7 TO rank = 0:
        FOR file = 0 TO file = 7:
            IF board & (1 << r * 8 + f) != 0:
                OUTPUT("1 ")
            ELSE:
                OUTPUT("0 ")
        NEXT file
        OUTPUT("\n")
    NEXT rank
ENDFUNC

METHOD Board.pretty_print():
    FOR rank = 7 TO rank = 0:
        OUTPUT(rank + " | ")
        FOR file = 0 TO file = 7:
            OUTPUT(char_piece_from_pos(rank, file)
        NEXT file
    NEXT rank
ENDMETHOD

METHOD Board.char_piece_from_pos(rank, file):
    square_bb = bitboard_from_pos(rank, file)
    IF sq_bb & self.white != 0:
        IF sq_bb & self.pawns != 0:
            RETURN 'P'
        ELSE IF sq_bb & self.knights != 0:
            // etc.
        ENDIF
    ELSE IF sq_bb & self.black != 0:
        IF sq_bb & self.pawns != 0:
            RETURN 'p'
        ELSE IF sq_bb & self.knights != 0:
            // etc.
        ENDIF
    ELSE
        RETURN 0
    ENDIF
ENDMETHOD

METHOD Board.make_move(move):
    (start, end, _is_castling, _is_en_passant, is_promotion, promotion_piece) =
        decompose_move(move)
    piece = self.piece_on(start)
    captured = self.piece_on(end)
    us = self.side_to_move
    them = us ^ 1

    start_bb = as_bitboard(start)
    end_bb = as_bitboard(end)

    self.pieces[piece] ^= start_bb | end_bb;
    self.sides[us] ^= start_bb | end_bb;
    NO_PIECE = 6
    IF captured != NO_PIECE:
        self.pieces[captured] ^= end_bb
        self.sides[them] ^= end_bb
    ENDIF

    self.piece_board[start] = NO_PIECE
    IF is_promotion:
        self.piece_board[end] = promotion_piece
        self.pieces[0] ^= end_bb
        self.pieces[promotion_piece] ^= end_bb
    ELSE
        self.piece_board[end] = piece
    ENDIF

    self.side_to_move ^= 1

    self.played_moves.push_move(move, piece, captured)
ENDMETHOD

METHOD Board.unmake_move():
    (
        start,
        end,
        _is_castling,
        _is_en_passant,
        is_promotion,
        promotion_piece,
        piece,
        captured,
    ) = self.played_moves.pop_move().decompose()
    self.side_to_move ^= 1
    us = self.side_to_move
    them = us ^ 1

    start_bb = as_bitboard(start)
    end_bb = as_bitboard(end)

    self.pieces[piece] ^= start_bb | end_bb;
    self.sides[us] ^= start_bb | end_bb;
    NO_PIECE = 6
    IF captured != NO_PIECE:
        self.pieces[captured] ^= end_bb
        self.sides[them] ^= end_bb
    ENDIF
    IF is_promotion:
        self.pieces[0] ^= end_bb
        self.pieces[promotion_piece] ^= end_bb
    ENDIF

    self.piece_board[end] = captured
    self.piece_board[start] = piece
ENDMETHOD

METHOD GameMove.decompose():
    (start, end, is_castling, is_en_passant, is_promotion, promotion_piece)
        = self.move.decompose()
    (
        start,
        end,
        is_castling,
        is_en_passant,
        is_promotion,
        promotion_piece,
        self.piece,
        self.captured,
    )
ENDMETHOD

FUNC GameMove.new(move, piece, captured):
    Self:
        captured,
        move,
        piece,
ENDFUNC

METHOD Move.decompose():
    start = self.move & 0x3f
    end = (self.move & 0xfc0) >> 6
    is_promotion = self.is_promotion()
    is_castling = self.is_castling()
    is_en_passant = self.is_en_passant()
    piece = (self.move >> 14) + 1
    (
        start,
        end,
        is_castling,
        is_en_passant,
        is_promotion,
        piece,
    )
ENDMETHOD

METHOD Move.is_promotion():
    self.move & 0x3000 == 0x3000
ENDMETHOD

METHOD Move.is_en_passant():
    self.move & 0x2000 != 0 && !self.is_promotion()
ENDMETHOD

METHOD Move.is_castling():
    self.move & 0x1000 != 0 && !self.is_promotion()
ENDMETHOD

METHOD Movelist.push_move(move, piece, captures):
    self.moves[self.first_empty] = GameMove::new(move, piece, captures)
    first_empty += 1
ENDMETHOD

METHOD Movelist.pop_move():
    self.first_empty -= 1
    RETURN self.moves[self.first_empty]
ENDMETHOD

FUNC perft(depth):
    IF depth == 0:
        RETURN 1
    ENDIF

    generate_moves()

    total = 0
    FOR move IN movelist:
        make_move()
        total += perft(depth - 1)
        unmake_move()
    NEXT move
    RETURN total
ENDFUNC

FUNC init_magics():
    b_offset = 0
    r_offset = 0

    FOR square = 0 TO square = 63:
        attacks[4096] = { 0 }
        edges = 0x8181818181818181 & !(0x0101010101010101 << file_of(square))
            | 0xff000000000000ff & !(0x00000000000000ff << rank_of(square))
        b_mask = sliding_attacks(square, 2, 0) & !edges
        r_mask = sliding_attacks(square, 3, 0) & !edges
        b_mask_bits = popcnt(b_mask)
        r_mask_bits = popcnt(r_mask)
        b_perms = pow(2, b_mask_bits)
        r_perms = pow(2, r_mask_bits)
        b_magic = Magic:
            magic = BISHOP_MAGICS[square],
            mask = b_mask,
            offset = b_offset,
            shift = 64 - b_mask_bits
        r_magic = Magic:
            magic = ROOK_MAGICS[square],
            mask = r_mask,
            offset = r_offset,
            shift = 64 - r_mask_bits

        generate_all_ray_attacks(square, piece, ray_attacks, attacks)
        blockers = b_mask
        FOR attack = 0 TO attack = b_perms:
            index = get_table_index(b_magic, blockers)
            bishop_magic_lookup[index] = attacks[attack]
            blockers = blockers - 1 & b_mask
        NEXT attack
        bishop_magics[square] = b_magic
        b_offset += b_perms

        generate_all_ray_attacks(square, piece, ray_attacks, attacks)
        blockers = r_mask
        FOR attack = 0 TO attack = r_perms:
            index = get_table_index(r_magic, blockers)
            rook_magic_lookup[index] = attacks[attack]
            blockers = blockers - 1 & r_mask
        NEXT attack
        rook_magics[square] = r_magic
        r_offset += r_perms
    NEXT square
ENDFUNC

FUNC find_magics(piece):
    IF piece == BISHOP:
        piece_str = "bishop"
    ELSE
        piece_str = "rook"
    ENDIF

    ray_attacks[8][64]
    attacks[4096] = { 0 }
    lookup_table[4096] = { 0 }
    epoch[4096] = { 0 }
    init_ray_attacks(ray_attacks)

    FOR square = 0 TO square = 63:
        IF piece == BISHOP:
            mask = bishop_mask(square, ray_attacks)
        ELSE
            mask = rook_mask(square, ray_attacks)
        ENDIF
        perms = popcnt(mask)
        shift = 64 - perms

        generate_all_ray_attacks(square, piece, ray_attacks, attacks)

        count = 0
        WHILE true:
            sparse_rand = gen_sparse_rand()
            blockers = mask
            found = true

            FOR i = 0 TO i = perms:
                index = blockers * sparse_rand >> shift

                IF epoch[index] < count:
                    epoch[index] = count
                    lookup_table[index] = attacks[i]
                ELSE IF lookup_table[index] != attacks[i]
                    found = false
                    break
                ENDIF
                blockers &= blockers - 1
            NEXT i

            IF found:
                OUTPUT("Found magic for " + piece_str + ": " + sparse_rand)
                break
            ENDIF

            count++
        ENDWHILE
    NEXT square
ENDFUNC

FUNC generate_moves(board, movelist):
    generate_pawn_moves(board, movelist)
    generate_non_sliding_moves(board, movelist)
    generate_sliding_moves(board, movelist)
ENDFUNC

FUNC generate_pawn_moves(board, movelist):
    us_bb = board.sides::<IS_WHITE>
    occupancies = board.occupancies()
    them_bb = occupancies ^ us_bb
    empty = !occupancies

    pawns = board.pieces::<0> & us_bb
    WHILE pawns != 0:
        pawn = pop_lsb(&pawns)
        single_push = pawn_push::<IS_WHITE>(pawn)
        IF IS_WHITE:
            double_push_rank = 0x00000000ff000000
        ELSE:
            double_push_rank = 0x000000ff00000000
        ENDIF
        double_push = pawn_push::<IS_WHITE>(single_push)
            & empty
            // 4 if we're White, 5 if we're Black
            & double_push_rank
        captures = pawn_attacks::<IS_WHITE>(to_square(pawn)) & them_bb
        targets = single_push | double_push | captures
        promotion_targets = targets & 0xff0000000000ff
        targets ^= promotion_targets
        WHILE targets != 0:
            target = pop_next_square(&targets)
            movelist.push_move(create_move::<IS_WHITE, 0>(to_square(pawn), target))
        ENDWHILE
        WHILE promotion_targets != 0:
            target = pop_next_square(&promotion_targets)
            movelist.push_move(create_move::<IS_WHITE, 1>(to_square(pawn), target))
            movelist.push_move(create_move::<IS_WHITE, 2>(to_square(pawn), target))
            movelist.push_move(create_move::<IS_WHITE, 3>(to_square(pawn), target))
            movelist.push_move(create_move::<IS_WHITE, 4>(to_square(pawn), target))
        ENDWHILE
    ENDWHILE
ENDFUNC

FUNC generate_non_sliding_moves(board, movelist)
    us_bb = board.sides[board.side_to_move]
    knights = board.pieces[1]

    WHILE knights != 0:
        knight = pop_lsb(knights)
        targets = knight_attacks[to_square(knight)] & ~us_bb
        WHILE targets != 0:
            target = pop_next_square(knight)
            movelist.push_move(to_square(knight), target)
        ENDWHILE
    ENDWHILE

    WHILE king != 0:
        knight = pop_lsb(king)
        targets = knight_attacks[to_square(king)] & ~us_bb
        WHILE targets != 0:
            target = pop_next_square(king)
            movelist.push_move(to_square(king), target)
        ENDWHILE
    ENDWHILE
FUNC

FUNC generate_sliding_moves(board, movelist):
    us = board.side_to_move
    us_bb = board.sides[us]
    them_bb = board.sides[1 - us]
    occupancies = us_bb | them_bb

    bishops = board.pieces[2] & us_bb
    WHILE bishops != 0:
        bishop = pop_lsb(&bishops)
        bishop_sq = to_square(bishop)
        targets = bishop_magic_lookup[
            get_table_index(bishop_magics[bishop_sq], occupancies)
        ] & !us_bb
        WHILE targets != 0:
            target = pop_next_square(targets)
            movelist.push_move(create_move(to_square(bishop), target, 2, us))
        ENDWHILE
    ENDWHILE

    rooks = board.pieces[3] & us_bb
    WHILE rooks != 0:
        rook = pop_lsb(&rooks)
        rook_sq = to_square(rook)
        targets = rook_magic_lookup[
            get_table_index(rook_magics[rook_sq], occupancies)
        ] & !us_bb
        WHILE targets != 0:
            target = pop_next_square(targets)
            movelist.push_move(create_move(to_square(rook), target, 3, us))
        ENDWHILE
    ENDWHILE

    queens = board.pieces[4] & us_bb
    WHILE queens != 0:
        queen = pop_lsb(&queens)
        queen_sq = to_square(queen)
        targets = rook_magic_lookup[
            get_table_index(rook_magics[rook_sq], occupancies)
        ] | bishop_magic_lookup[
            get_table_index(bishop_magics[bishop_sq], occupancies)
        ] & !us_bb
        WHILE targets != 0:
            target = pop_next_square(targets)
            movelist.push_move(create_move(to_square(queen), target, 4, us))
        ENDWHILE
    ENDWHILE
ENDFUNC

FUNC init_pawn_attacks():
    FOR side = 0 TO side = 1:
        FOR square = 0 TO square = 63:
            push = 1 << (square + 8 - side * 16)
            attacks = east(push) | west(push)
            pawn_attacks[side][square] = attacks
        NEXT square
    NEXT side
ENDFUNC

FUNC init_knight_attacks():
    FOR square = 0 TO square = 63
        knight = 1 << square
        e = east(knights)
        w = west(knights)
        attacks = north(north(e | w))
        attacks |= south(south(e | w))
        e = east(e)
        w = west(w)
        attacks = north(north(e | w))
        attacks |= south(south(e | w))
        knight_attacks[square] = attacks
    NEXT square
ENDFUNC

FUNC init_king_attacks():
    FOR square = 0 TO square = 63
        king = 1 << square
        attacks = east(king) | west(king) | king
        attacks |= north(attacks) | south(attacks)
        attacks ^= king
        king_attacks[square] = attacks
    NEXT square
ENDFUNC

FUNC init_ray_attacks(ray_attacks)
    a2_h8 = 0x0101010101010100
    FOR square = 0 TO square = 63:
        ray_attacks[0][square] = a2_h8 << square
    NEXT square

    b2_h8 = 0x8040201008040200
    FOR file = 0 TO file = 6:
        top_rank = file + 56
        FOR square = file TO square = top_rank - 8 STEP 8:
            ray_attacks[1][square] = b2_h8 << square
        NEXT square
        b2_h8 &= ~(0x0101010101010101 << (7 - file))
    NEXT file

    b1_h1 = 0x00000000000000fe
    FOR file = 0 TO file = 6:
        top_rank = file + 56
        FOR square = file TO square = top_rank STEP 8:
            ray_attacks[2][square] = b1_h1 << square
        NEXT square
        b1_h1 &= ~(0x0101010101010101 << (7 - file))
    NEXT file

    b7_h1 = 0x0002040810204080
    square = 56
    WHILE b7_h1 != 0:
        FOR rank = 0 TO rank = 48 STEP 8:
            ray_attacks[3][square] = b7_h1 >> rank
            square -= 8
        NEXT rank

        b7_h1 <<= 1
        b7_h1 &= ~0x0101010101010101
        square += 57
    ENDWHILE

    h7_h1 = 0x0080808080808080
    FOR square = 8 TO square = 56:
        ray_attacks[4][square] = h7_h1 >> (square ^ 63)
    NEXT square

    g7_a1 = 0x0040201008040201
    square = 63
    WHILE g7_a1 != 0:
        FOR file = 0 TO file = 48 STEP 8:
            ray_attacks[5][square] = g7_a1 >> file
            square -= 8
        NEXT file

        g7_a1 >>= 1
        g7_a1 &= ~0x8080808080808080
        square += 55
    ENDWHILE

    square = 7
    g1_a1 = 0x000000000000007f
    WHILE h1_a1 != 0:
        FOR rank = 0 TO rank = 56 STEP 8:
            ray_attacks[6][square] = h1_a1 << rank
            square += 8
        NEXT rank

        h1_a1 >>= 1
        square -= 65
    ENDWHILE

    square = 7
    g2_a8 = 0x0102040810204000
    WHILE g2_a8 != 0:
        FOR rank = 0 TO rank = 48 STEP 8:
            ray_attacks[7][square] = g2_a8 << rank
            square += 8
        NEXT rank

        g2_a8 >>= 1
        g2_a8 &= ~0x8080808080808080
        square -= 57
    ENDWHILE
ENDFUNC

FUNC north(bb)
    bb << 8
ENDFUNC

FUNC south(bb)
    bb >> 8
ENDFUNC

FUNC east(bb)
    FILE_A = 0x0101010101010101
    RETURN bb << 1 & ~FILE_A
ENDFUNC

FUNC west(bb)
    FILE_H = 0x8080808080808080
    RETURN bb >> 1 & ~FILE_H
ENDFUNC

FUNC pop_lsb(&bb):
    ret = *bb & -*bb
    *bb &= *bb - 1
    RETURN ret
ENDFUNC

FUNC pop_next_square(&bb):
    ret = bit_scan_forward(*bb)
    *bb &= *bb - 1
    RETURN ret
ENDFUNC
