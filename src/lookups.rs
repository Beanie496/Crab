/*
 * Crab, a UCI-compatible chess engine
 * Copyright (C) 2024 Jasper Shovelton
 *
 * Crab is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option) any later
 * version.
 *
 * Crab is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * Crab. If not, see <https://www.gnu.org/licenses/>.
 */

use std::mem::transmute;

use crate::{
    bitboard::Bitboard,
    cfor,
    defs::{PieceType, Side, Square},
    search::Depth,
    util::get_unchecked,
};
use magic::{Magic, BISHOP_MAGICS, ROOK_MAGICS};
use util::{bitboard_from_square, east, north, sliding_attacks, south, west};

/// Items related to magic bitboards.
pub mod magic;
/// Useful functions for move generation.
mod util;

/// A table of base late move reductions.
///
/// Indexed by the depth then number of legal moves.
type BaseReductions = [[Depth; 128]; 64];

/// A table of base late move reductions.
///
/// Generated by the build script.
static BASE_REDUCTIONS: BaseReductions =
    unsafe { transmute(*include_bytes!("../binaries/base_reductions.bin")) };
/// A table of attacks for each piece.
pub static ATTACK_LOOKUPS: AttackLookups = AttackLookups::new();
/// A table of rays between two squares, excluding the squares themselves.
///
/// If an orthogonal or diagonal ray cannot be drawn between the two squares,
/// the bitboard will be empty.
static RAYS_BETWEEN: [[Bitboard; Square::TOTAL]; Square::TOTAL] =
    unsafe { transmute(*include_bytes!("../binaries/rays_between.bin")) };

/// The number of bitboards required to store all bishop attacks, where each
/// element corresponds to one permutation of blockers.
///
/// Some elements will be duplicates, as different blockers can have the same
/// attacks. Repeated once per quadrant: `2.pow(6)` blocker permutations for
/// the corner, `2.pow(5)` for each non-corner edge and each square adjacent to
/// an edge, `2.pow(7)` for the squares adjacent or diagonal to a corner and
/// `2.pow(9)` for the centre.
const BISHOP_SIZE: usize = 5_248;
/// The number of bitboards required to store all rook attacks, where each
/// element corresponds to one permutation of blockers.
///
/// Some elements will be duplicates, as different blockers can have the same
/// attacks. There are `2.pow(12)` blocker permutations for each corner,
/// `2.pow(11)` for each non-corner edge and `2.pow(10)` for all others.
const ROOK_SIZE: usize = 102_400;

/// Contains lookup tables for each piece.
pub struct AttackLookups {
    /// The pawn attack table. `pawn_attacks[side][square] == attack bitboard
    /// for that square`.
    pawn_attacks: [[Bitboard; Square::TOTAL]; Side::TOTAL],
    /// The knight attack table. `knight_attacks[square] == attack bitboard for
    /// that square`.
    knight_attacks: [Bitboard; Square::TOTAL],
    /// The king attack table. `king_attacks[square] == attack bitboard for
    /// that square`.
    king_attacks: [Bitboard; Square::TOTAL],
    /// The magic lookup table for rooks and bishops.
    ///
    /// The rook attacks are before all the bishop attacks. It uses the 'fancy'
    /// approach. See <https://www.chessprogramming.org/Magic_Bitboards>.
    magic_table: [Bitboard; ROOK_SIZE + BISHOP_SIZE],
    /// The (wrapped) magic numbers for the bishop. One per square.
    ///
    /// See <https://www.chessprogramming.org/Magic_Bitboards>.
    bishop_magics: [Magic; Square::TOTAL],
    /// The (wrapped) magic numbers for the rook. One per square.
    ///
    /// See <https://www.chessprogramming.org/Magic_Bitboards>.
    rook_magics: [Magic; Square::TOTAL],
}

impl AttackLookups {
    /// Creates new lookup tables.
    ///
    /// This is meant to be called once at compile time.
    #[allow(clippy::large_stack_frames)]
    const fn new() -> Self {
        let pawn_attacks = Self::init_pawn_attacks();
        let king_attacks = Self::init_king_attacks();
        let knight_attacks = Self::init_knight_attacks();
        let (magic_table, bishop_magics, rook_magics) = Self::init_magics();

        Self {
            pawn_attacks,
            knight_attacks,
            king_attacks,
            magic_table,
            bishop_magics,
            rook_magics,
        }
    }

    /// Calculates and returns lookup tables for both pawns.
    ///
    /// `init_pawn_attacks()[Side::WHITE.to_index() == White pawn attack table`
    const fn init_pawn_attacks() -> [[Bitboard; Square::TOTAL]; Side::TOTAL] {
        let mut pawn_attacks = [[Bitboard::empty(); Square::TOTAL]; Side::TOTAL];
        cfor!(let mut square = 0; square < Square::TOTAL; square += 1; {
            let pawn = bitboard_from_square(square as u8);
            let pushed_white = north(pawn);
            let pushed_black = south(pawn);
            pawn_attacks[Side::WHITE.to_index()][square] =
                Bitboard(east(pushed_white) | west(pushed_white));
            pawn_attacks[Side::BLACK.to_index()][square] =
                Bitboard(east(pushed_black) | west(pushed_black));
        });
        pawn_attacks
    }

    /// Calculates and returns a lookup table for the knight.
    const fn init_knight_attacks() -> [Bitboard; Square::TOTAL] {
        let mut knight_attacks = [Bitboard::empty(); Square::TOTAL];
        cfor!(let mut square = 0; square < Square::TOTAL; square += 1; {
            let knight = bitboard_from_square(square as u8);
            let mut e = east(knight);
            let mut w = west(knight);
            let mut attacks = north(north(e | w));
            attacks |= south(south(e | w));

            e = east(e);
            w = west(w);
            attacks |= north(e | w);
            attacks |= south(e | w);

            knight_attacks[square] = Bitboard(attacks);
        });
        knight_attacks
    }

    /// Calculates and returns a lookup table for the king.
    const fn init_king_attacks() -> [Bitboard; Square::TOTAL] {
        let mut king_attacks = [Bitboard::empty(); Square::TOTAL];
        cfor!(let mut square = 0; square < Square::TOTAL; square += 1; {
            let king = bitboard_from_square(square as u8);

            let mut attacks = east(king) | west(king) | king;
            attacks |= north(attacks) | south(attacks);
            attacks ^= king;

            king_attacks[square] = Bitboard(attacks);
        });
        king_attacks
    }

    /// Calculates and returns the magic lookup table and magic structs.
    ///
    /// `init_magics() == (magic_table, bishop_magics, rook_magics)`.
    #[allow(clippy::large_stack_arrays, clippy::large_stack_frames)]
    const fn init_magics() -> (
        [Bitboard; ROOK_SIZE + BISHOP_SIZE],
        [Magic; Square::TOTAL],
        [Magic; Square::TOTAL],
    ) {
        let mut b_offset = ROOK_SIZE;
        let mut r_offset = 0;
        let mut magic_table = [Bitboard::empty(); ROOK_SIZE + BISHOP_SIZE];
        let mut bishop_magics = [Magic::null(); Square::TOTAL];
        let mut rook_magics = [Magic::null(); Square::TOTAL];

        cfor!(let mut square = 0; square < Square::TOTAL; square += 1; {
            let square = Square(square as u8);
            let edges = Bitboard::edges_without(square).0;
            let b_mask =
                sliding_attacks::<{ PieceType::BISHOP.0 }>(square, Bitboard::empty()).0 & !edges;
            let r_mask =
                sliding_attacks::<{ PieceType::ROOK.0 }>(square, Bitboard::empty()).0 & !edges;
            let b_mask_bits = b_mask.count_ones();
            let r_mask_bits = r_mask.count_ones();
            let b_perms = 2_usize.pow(b_mask_bits);
            let r_perms = 2_usize.pow(r_mask_bits);

            let b_magic = Magic::new(
                BISHOP_MAGICS[square.to_index()],
                Bitboard(b_mask),
                b_offset,
                64 - b_mask_bits,
            );
            bishop_magics[square.to_index()] = b_magic;
            let r_magic = Magic::new(
                ROOK_MAGICS[square.to_index()],
                Bitboard(r_mask),
                r_offset,
                64 - r_mask_bits,
            );
            rook_magics[square.to_index()] = r_magic;

            let mut blockers = b_mask;
            cfor!(let mut attack = 0; attack < b_perms; attack += 1; {
                let index = b_magic.get_table_index(Bitboard(blockers));
                magic_table[index] = sliding_attacks::<{ PieceType::BISHOP.0 }>(square, Bitboard(blockers));
                blockers = blockers.wrapping_sub(1) & b_mask;
            });

            let mut blockers = r_mask;
            cfor!(let mut attack = 0; attack < r_perms; attack += 1; {
                let index = r_magic.get_table_index(Bitboard(blockers));
                magic_table[index] = sliding_attacks::<{ PieceType::ROOK.0 }>(square, Bitboard(blockers));
                blockers = blockers.wrapping_sub(1) & r_mask;
            });

            b_offset += b_perms;
            r_offset += r_perms;
        });
        (magic_table, bishop_magics, rook_magics)
    }

    /// Finds the pawn attacks from `square`.
    pub fn pawn_attacks(&self, side: Side, square: Square) -> Bitboard {
        let side_table = get_unchecked(&self.pawn_attacks, side.to_index());
        *get_unchecked(side_table, square.to_index())
    }

    /// Finds the knight attacks from `square`.
    pub fn knight_attacks(&self, square: Square) -> Bitboard {
        *get_unchecked(&self.knight_attacks, square.to_index())
    }

    /// Finds the king attacks from `square`.
    pub fn king_attacks(&self, square: Square) -> Bitboard {
        *get_unchecked(&self.king_attacks, square.to_index())
    }

    /// Finds the bishop attacks from `square` with the given blockers.
    pub fn bishop_attacks(&self, square: Square, blockers: Bitboard) -> Bitboard {
        let index = get_unchecked(&self.bishop_magics, square.to_index()).get_table_index(blockers);
        *get_unchecked(&self.magic_table, index)
    }

    /// Finds the rook attacks from `square` with the given blockers.
    pub fn rook_attacks(&self, square: Square, blockers: Bitboard) -> Bitboard {
        let index = get_unchecked(&self.rook_magics, square.to_index()).get_table_index(blockers);
        *get_unchecked(&self.magic_table, index)
    }

    /// Finds the queen attacks from `square` with the given blockers.
    pub fn queen_attacks(&self, square: Square, blockers: Bitboard) -> Bitboard {
        self.bishop_attacks(square, blockers) | self.rook_attacks(square, blockers)
    }
}

/// Finds the base late move reduction for the given number of moves and the
/// given depth.
pub fn base_reductions(depth: Depth, total_moves: u8) -> Depth {
    let move_table = get_unchecked(&BASE_REDUCTIONS, depth.to_index().min(63));
    *get_unchecked(move_table, usize::from(total_moves).min(127))
}

/// Finds the bitboard ray between `start` and `end`.
///
/// It will be an empty bitboard if there cannot be a ray between `start` and
/// `end`.
pub fn ray_between(start: Square, end: Square) -> Bitboard {
    let first_square = get_unchecked(&RAYS_BETWEEN, usize::from(start.0));
    *get_unchecked(first_square, usize::from(end.0))
}
